var q=a=>{throw TypeError(a)};var C=(a,e,t)=>e.has(a)||q("Cannot "+t);var i=(a,e,t)=>(C(a,e,"read from private field"),t?t.call(a):e.get(a)),w=(a,e,t)=>e.has(a)?q("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,t),b=(a,e,t,r)=>(C(a,e,"write to private field"),r?r.call(a,t):e.set(a,t),t),P=(a,e,t)=>(C(a,e,"access private method"),t);import{S as _,U as K,V as z,W as I,Y as k,C as O,r as H,Z as B,_ as R,B as x,$ as S,a0 as L,u as T,D as $}from"./index-DrqidrQV.js";var f,v,m,g,y,M,A,Q,F=(Q=class extends _{constructor(e,t){super();w(this,y);w(this,f);w(this,v);w(this,m);w(this,g);b(this,f,e),this.setOptions(t),this.bindMethods(),P(this,y,M).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(e){var r;const t=this.options;this.options=i(this,f).defaultMutationOptions(e),K(this.options,t)||i(this,f).getMutationCache().notify({type:"observerOptionsUpdated",mutation:i(this,m),observer:this}),t!=null&&t.mutationKey&&this.options.mutationKey&&z(t.mutationKey)!==z(this.options.mutationKey)?this.reset():((r=i(this,m))==null?void 0:r.state.status)==="pending"&&i(this,m).setOptions(this.options)}onUnsubscribe(){var e;this.hasListeners()||(e=i(this,m))==null||e.removeObserver(this)}onMutationUpdate(e){P(this,y,M).call(this),P(this,y,A).call(this,e)}getCurrentResult(){return i(this,v)}reset(){var e;(e=i(this,m))==null||e.removeObserver(this),b(this,m,void 0),P(this,y,M).call(this),P(this,y,A).call(this)}mutate(e,t){var r;return b(this,g,t),(r=i(this,m))==null||r.removeObserver(this),b(this,m,i(this,f).getMutationCache().build(i(this,f),this.options)),i(this,m).addObserver(this),i(this,m).execute(e)}},f=new WeakMap,v=new WeakMap,m=new WeakMap,g=new WeakMap,y=new WeakSet,M=function(){var t;const e=((t=i(this,m))==null?void 0:t.state)??I();b(this,v,{...e,isPending:e.status==="pending",isSuccess:e.status==="success",isError:e.status==="error",isIdle:e.status==="idle",mutate:this.mutate,reset:this.reset})},A=function(e){k.batch(()=>{var t,r,u,o,c,s,h,E;if(i(this,g)&&this.hasListeners()){const p=i(this,v).variables,n=i(this,v).context;(e==null?void 0:e.type)==="success"?((r=(t=i(this,g)).onSuccess)==null||r.call(t,e.data,p,n),(o=(u=i(this,g)).onSettled)==null||o.call(u,e.data,null,p,n)):(e==null?void 0:e.type)==="error"&&((s=(c=i(this,g)).onError)==null||s.call(c,e.error,p,n),(E=(h=i(this,g)).onSettled)==null||E.call(h,void 0,e.error,p,n))}this.listeners.forEach(p=>{p(i(this,v))})})},Q);function D(a,e){const t=O(),[r]=H.useState(()=>new F(t,a));H.useEffect(()=>{r.setOptions(a)},[r,a]);const u=H.useSyncExternalStore(H.useCallback(c=>r.subscribe(k.batchCalls(c)),[r]),()=>r.getCurrentResult(),()=>r.getCurrentResult()),o=H.useCallback((c,s)=>{r.mutate(c,s).catch(B)},[r]);if(u.error&&R(r.options.throwOnError,[u.error]))throw u.error;return{...u,mutate:o,mutateAsync:u.mutate}}/**
 * @license lucide-react v0.411.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const W=x("Camera",[["path",{d:"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",key:"1tc9qg"}],["circle",{cx:"12",cy:"13",r:"3",key:"1vg3eu"}]]);class N{async updatePlantHealthDiagnosis(e){var o,c;if(console.log("🩺 [Health] Iniciando actualización de diagnóstico para:",e.name),!e.images||e.images.length===0)throw new Error("Esta planta no tiene imágenes para analizar. Toma una foto primero.");const t=e.images.sort((s,h)=>h.timestamp.getTime()-s.timestamp.getTime())[0];console.log("📸 [Health] Analizando imagen más reciente:",{imageId:t.id,timestamp:t.timestamp,imageUrl:t.url.substring(0,100)+"..."});const{data:{session:r},error:u}=await S.auth.getSession();if(u||!(r!=null&&r.access_token))throw console.error("💥 [Health] User session not available:",u),new Error("Usuario no autenticado. Por favor inicia sesión nuevamente.");try{const s=await fetch(t.url,{method:"HEAD"});if(!s.ok)throw new Error(`Imagen no accesible: ${s.status}`)}catch(s){throw console.error("💥 [Health] Error verificando acceso a imagen:",s),new Error("La imagen de la planta no está disponible. Intenta tomar una nueva foto.")}console.log("🔬 [Health] Llamando a update-health-diagnosis...");try{const{data:s,error:h}=await S.functions.invoke("update-health-diagnosis",{body:{imageUrl:t.url,plantName:e.name,species:e.species},headers:{Authorization:`Bearer ${r.access_token}`}});if(h)throw console.error("💥 [Health] Error en función update-health-diagnosis:",h),new Error(`Error en análisis: ${h.message}`);if(!s||!s.overallHealth)throw console.error("💥 [Health] Datos incompletos del análisis:",s),new Error("El análisis no devolvió información de salud válida.");console.log("🎯 [Health] Análisis de salud completado exitosamente:",{overallHealth:s.overallHealth,confidence:s.confidence,issuesCount:((o=s.issues)==null?void 0:o.length)||0,recommendationsCount:((c=s.recommendations)==null?void 0:c.length)||0});const p={excellent:95,good:80,fair:60,poor:30}[s.overallHealth]||s.confidence||60;return console.log("📊 [Health] Nuevo score de salud calculado:",{overallHealth:s.overallHealth,numericScore:p,confidence:s.confidence}),{healthScore:p,healthAnalysis:s,updatedImage:{...t,healthAnalysis:s}}}catch(s){console.error("💥 [Health] Error en diagnóstico primario:",s),console.log("🔄 [Health] Intentando análisis de fallback...");try{if(t.healthAnalysis&&t.healthAnalysis.overallHealth){console.log("🎯 [Health] Usando análisis existente de la imagen");const h=t.healthAnalysis;return{healthScore:{excellent:95,good:80,fair:60,poor:30}[h.overallHealth]||60,healthAnalysis:h,updatedImage:t}}}catch(h){console.error("💥 [Health] Error en fallback:",h)}throw new Error("No se pudo actualizar el diagnóstico de salud. Verifica tu conexión a internet e intenta nuevamente.")}}async updatePlantHealthScore(e,t,r,u,o){try{console.log("🏥 [DB] Actualizando health score en BD:",{plantId:e,healthScore:r,hasAnalysis:!!u});const{error:c}=await S.from("plants").update({health_score:r}).eq("id",e).eq("user_id",t);if(c)throw console.error("💥 [DB] Error actualizando health score:",c),new Error(`Error updating plant health score: ${c.message}`);if(u&&o){console.log("📸 [DB] Actualizando análisis de salud en imagen:",o);const{error:s}=await S.from("plant_images").update({health_analysis:u}).eq("id",o).eq("user_id",t);s&&console.warn("⚠️ [DB] Error actualizando análisis en imagen:",s)}console.log("✅ [DB] Health score actualizado exitosamente")}catch(c){throw console.error("💥 [DB] Error en updatePlantHealthScore:",c),c}}}const U=new N,Y=()=>{const a=O(),{addPlant:e,updatePlant:t,deletePlant:r}=L.getState(),u=T(n=>n.user),o=u==null?void 0:u.id,{addToast:c}=$(),s=D({mutationFn:n=>{if(!o)throw new Error("User not authenticated");const{imageDataUrl:d,location:l}=n;return e(d,l,o)},onSuccess:n=>{a.invalidateQueries({queryKey:["plants",o]})},onError:n=>{console.error("Failed to create plant:",n)}}),h=D({mutationFn:n=>{if(!o)throw new Error("User not authenticated");return t(n,o)},onMutate:async n=>{await a.cancelQueries({queryKey:["plants",o]});const d=a.getQueryData(["plants",o]);return d&&a.setQueryData(["plants",o],d.map(l=>l.id===n.id?n:l)),{previousPlants:d}},onError:(n,d,l)=>{l!=null&&l.previousPlants&&a.setQueryData(["plants",o],l.previousPlants)},onSettled:n=>{a.invalidateQueries({queryKey:["plants",o]})}}),E=D({mutationFn:async({plant:n,userId:d})=>{console.log("🩺 [Mutation] Iniciando actualización de diagnóstico...");const l=await U.updatePlantHealthDiagnosis(n);return await U.updatePlantHealthScore(n.id,d,l.healthScore,l.healthAnalysis,l.updatedImage.id),console.log("✅ [Mutation] Diagnóstico actualizado exitosamente"),l},onSuccess:(n,{plant:d})=>{a.invalidateQueries({queryKey:["plants"]}),a.invalidateQueries({queryKey:["plant",d.id]}),c({type:"success",title:"Diagnóstico Actualizado",message:`Nuevo estado de salud: ${n.healthScore}%`})},onError:n=>{console.error("💥 [Mutation] Error actualizando diagnóstico:",n),c({type:"error",title:"Error en Diagnóstico",message:n.message})}}),p=D({mutationFn:n=>{if(!o)throw new Error("User not authenticated");return r(n,o)},onMutate:async n=>{await a.cancelQueries({queryKey:["plants",o]});const d=a.getQueryData(["plants",o]);return d&&a.setQueryData(["plants",o],d.filter(l=>l.id!==n)),{previousPlants:d}},onError:(n,d,l)=>{l!=null&&l.previousPlants&&a.setQueryData(["plants",o],l.previousPlants)},onSettled:()=>{a.invalidateQueries({queryKey:["plants",o]})}});return{createPlant:s.mutate,isCreatingPlant:s.isPending,updatePlant:h.mutate,isUpdatingPlant:h.isPending,updatePlantHealthMutation:E.mutate,isUpdatingPlantHealth:E.isPending,deletePlant:p.mutate,isDeletingPlant:p.isPending}};export{W as C,D as a,Y as u};
